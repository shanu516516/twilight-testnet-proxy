error_log /dev/stderr info;
map $http_upgrade $connection_upgrade {
  default upgrade;
  ''      close;
}
client_max_body_size 10m;
client_body_buffer_size 128k;
# ---- njs & resolver (for ngx.fetch and verify.js) ----
resolver 1.1.1.1 1.0.0.1 valid=300s ipv6=off;
js_path /etc/nginx/njs;
js_import verify from verify.js;
map "" $njs_debug { default "1"; }

map "" $rpc_upstream_url { default "http://${RPC_HOST}"; }

# ---- upstreams (parameterize if you like) ----
upstream relayer     { server ${RELAYER_BACKEND}; }
upstream orderapi    { server ${ORDERAPI_BACKEND};  }
upstream auth        { server ${AUTH_BACKEND};       }
upstream api         { server ${WEB_BACKEND};       }
upstream ws          { server ${WS_BACKEND};        }
upstream whitelist   { server ${WHITELIST_HOST};    }
upstream verifier    { server ${VERIFIER_URL};       }

# ---------- :80 redirectors ----------
# relayer.${DOMAIN}
server {
  listen 80; listen [::]:80;
  server_name relayer.${DOMAIN} www.relayer.${DOMAIN};
  server_tokens off;
  location /.well-known/acme-challenge/ { root /var/www/certbot; }
  location / { return 301 https://relayer.${DOMAIN}$request_uri; }
}

# frontend.${DOMAIN}
server {
  listen 80; listen [::]:80;
  server_name frontend.${DOMAIN} www.frontend.${DOMAIN};
  server_tokens off;
  location /.well-known/acme-challenge/ { root /var/www/certbot; }
  location / { return 301 https://frontend.${DOMAIN}$request_uri; }
}

# lcd.${DOMAIN}
server {
    listen 80; listen [::]:80;
    server_name lcd.${DOMAIN} www.lcd.${DOMAIN};
    server_tokens off;
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }
    location / {
        return 301 https://lcd.${DOMAIN}$request_uri;
    }
}

# rpc.${DOMAIN}
server {
    listen 80; listen [::]:80;
    server_name rpc.${DOMAIN} www.rpc.${DOMAIN};
    server_tokens off;
    location /.well-known/acme-challenge/ { root /var/www/certbot; }
    location / { return 301 https://rpc.${DOMAIN}$request_uri; }
}

# zkos.${DOMAIN}
server {
    listen 80; listen [::]:80;
    server_name zkos.${DOMAIN} www.zkos.${DOMAIN};
    server_tokens off;
    location /.well-known/acme-challenge/ { root /var/www/certbot; }
    location / { return 301 https://zkos.${DOMAIN}$request_uri; }
}

# faucet.${DOMAIN}
server {
    listen 80; listen [::]:80;
    server_name faucet.${DOMAIN} www.faucet.${DOMAIN};
    server_tokens off;
    location /.well-known/acme-challenge/ { root /var/www/certbot; }
    location / { return 301 https://faucet.${DOMAIN}$request_uri; }
}

# explorer.${DOMAIN}
server {
    listen 80; listen [::]:80;
    server_name explorer.${DOMAIN} www.explorer.${DOMAIN};
    server_tokens off;
    location /.well-known/acme-challenge/ { root /var/www/certbot; }
    location / { return 301 https://explorer.${DOMAIN}$request_uri; }
}

# zk-kyc.${DOMAIN}
server {
    listen 80; listen [::]:80;
    server_name zk-kyc.${DOMAIN} www.zk-kyc.${DOMAIN};
    server_tokens off;
    location /.well-known/acme-challenge/ { root /var/www/certbot; }
    location / { return 301 https://zk-kyc.${DOMAIN}$request_uri; }
}

# ---------- relayer.${DOMAIN} :443 ----------
server {
  listen 443 ssl; listen [::]:443 ssl;
  http2 on;
  server_name relayer.${DOMAIN};

  ssl_certificate     /etc/nginx/ssl/live/relayer.${DOMAIN}/fullchain.pem;
  ssl_certificate_key /etc/nginx/ssl/live/relayer.${DOMAIN}/privkey.pem;

  location /relayer   { proxy_pass http://relayer; }
  location /clientapi { proxy_pass http://orderapi; }
  location /whitelist { 
    proxy_pass http://whitelist;
    proxy_http_version 1.1;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    add_header Access-Control-Allow-Origin *;
    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
    add_header Access-Control-Allow-Headers 'Content-Type, Authorization';
  }

  location /ws {
    proxy_pass http://ws;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $connection_upgrade;
  }

  location = /check        { proxy_pass http://api; }
  location = /api/private  { proxy_pass http://api; }
  location /api            { proxy_pass http://api; }

  location = /register     { proxy_pass http://auth/register; }
  location = /regenerate   { proxy_pass http://api; }
}

# ---------- lcd.${DOMAIN} :443 (1317) ----------
server {
  listen 443 ssl; listen [::]:443 ssl;
  server_name lcd.${DOMAIN};
  ssl_certificate     /etc/nginx/ssl/live/lcd.${DOMAIN}/fullchain.pem;
  ssl_certificate_key /etc/nginx/ssl/live/lcd.${DOMAIN}/privkey.pem;

  location / {
    proxy_pass http://${LCD_HOST}/;
    proxy_http_version 1.1;
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
    add_header Access-Control-Allow-Headers 'Content-Type, Authorization';
    if ($request_method = OPTIONS) {
      add_header Content-Length 0;
      add_header Content-Type text/plain;
      return 204;
    }
  }
}

# ---------- rpc.${DOMAIN} :443 (26657 + WS) ----------

server {
  listen 443 ssl; listen [::]:443 ssl;
  server_name rpc.${DOMAIN};
  ssl_certificate     /etc/nginx/ssl/live/rpc.${DOMAIN}/fullchain.pem;
  ssl_certificate_key /etc/nginx/ssl/live/rpc.${DOMAIN}/privkey.pem;
# define a variable NJS will write into
  set $req_body "";

  # INTERNAL verifier (unchanged, but ensure we pass the original body there too)
  location = /__verifier {
    internal;
    proxy_pass http://verifier;
    proxy_http_version 1.1;

    # forward the client's original JSON body to the verifier
    proxy_set_body                 $request_body;
    proxy_set_header Content-Type  $http_content_type;
    proxy_set_header Content-Length $content_length;

    proxy_set_header Host          $proxy_host;
    proxy_set_header Connection    "";
    proxy_read_timeout 5s;
    resolver 1.1.1.1 1.0.0.1 valid=300s ipv6=off;
    proxy_ssl_server_name on;
  }

  # Named location for GET/other (no body)
  location @up_get {
    proxy_pass http://${RPC_HOST};
    proxy_http_version 1.1;

    proxy_set_header Host            $proxy_host;
    proxy_set_header X-Real-IP       $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Connection      "";
    proxy_set_header Accept-Encoding $http_accept_encoding;

    proxy_read_timeout 60s;

    # avoid duplicate CORS from upstream; njs sets ours
    proxy_hide_header Access-Control-Allow-Origin;
    proxy_hide_header Access-Control-Allow-Methods;
    proxy_hide_header Access-Control-Allow-Headers;

    # one consistent CORS set (njs also sets for 4xx/403)
    add_header Access-Control-Allow-Origin  *                                  always;
    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'               always;
    add_header Access-Control-Allow-Headers 'Content-Type, Authorization'      always;
  }

  # Named location for POST (restore the saved body)
  location @up_post {
    proxy_pass http://${RPC_HOST};
    proxy_http_version 1.1;

    proxy_set_header Host            $proxy_host;
    proxy_set_header X-Real-IP       $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Connection      "";
    proxy_set_header Accept-Encoding $http_accept_encoding;

    # restore body captured by NJS
    proxy_set_body $req_body;
    # let nginx chunk if length unknown
    proxy_set_header Content-Type application/json;
    # proxy_set_header Content-Length "";

    proxy_request_buffering on;
    proxy_read_timeout 60s;

    proxy_hide_header Access-Control-Allow-Origin;
    proxy_hide_header Access-Control-Allow-Methods;
    proxy_hide_header Access-Control-Allow-Headers;

    add_header Access-Control-Allow-Origin  *                                  always;
    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'               always;
    add_header Access-Control-Allow-Headers 'Content-Type, Authorization'      always;
  }

  # WebSocket target (unchanged)
  location @up_ws {
    proxy_pass http://${RPC_HOST};
    proxy_http_version 1.1;
    proxy_set_header Upgrade    $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_read_timeout 60s;

    add_header Access-Control-Allow-Origin  *                                  always;
    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'               always;
    add_header Access-Control-Allow-Headers 'Content-Type, Authorization'      always;
  }

  # Public entry â€” NJS gates then redirects internally
  location / {
    js_content verify.entry;
  }
}
# ---------- frontend.${DOMAIN} -> frontend ----------
server {
  listen 443 ssl; listen [::]:443 ssl;
  server_name frontend.${DOMAIN};
  ssl_certificate     /etc/nginx/ssl/live/frontend.${DOMAIN}/fullchain.pem;
  ssl_certificate_key /etc/nginx/ssl/live/frontend.${DOMAIN}/privkey.pem;

  location / {
    proxy_pass http://${FRONTEND};
    proxy_http_version 1.1;
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    add_header Access-Control-Allow-Origin  *;
    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
    add_header Access-Control-Allow-Headers 'Content-Type, Authorization';
    if ($request_method = OPTIONS) {
      add_header Content-Length 0;
      add_header Content-Type text/plain;
      return 204;
    }
  }
}

# zkos.${DOMAIN} :443
server {
    listen 443 ssl; listen [::]:443 ssl;
    server_name zkos.${DOMAIN};

    ssl_certificate     /etc/nginx/ssl/live/zkos.${DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/nginx/ssl/live/zkos.${DOMAIN}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    location / {
      proxy_pass http://${ZKOS_HOST};
    }
}

# faucet.${DOMAIN} :443 (6969)
server {
    listen 443 ssl; listen [::]:443 ssl;
    server_name faucet.${DOMAIN};

    ssl_certificate     /etc/nginx/ssl/live/faucet.${DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/nginx/ssl/live/faucet.${DOMAIN}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    location / {
        proxy_pass http://${FAUCET_HOST}/;
        proxy_http_version          1.1;
        proxy_set_header Host       $host;
        proxy_set_header X-Real-IP  $remote_addr;
        proxy_hide_header Access-Control-Allow-Origin;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        add_header Access-Control-Allow-Origin  *;
        add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
        add_header Access-Control-Allow-Headers 'Content-Type, Authorization';
        if ($request_method = OPTIONS) {
            add_header Access-Control-Allow-Origin  *                                      always;
            add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'                   always;
            add_header Access-Control-Allow-Headers 'Content-Type, Authorization'          always;
            add_header Content-Length 0;
            add_header Content-Type text/plain;
            return 204;
        }
    }
}

# explorer.${DOMAIN} :443
server {
    listen 443 ssl; listen [::]:443 ssl;
    server_name explorer.${DOMAIN};

    ssl_certificate     /etc/nginx/ssl/live/explorer.${DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/nginx/ssl/live/explorer.${DOMAIN}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    location / {
        proxy_pass http://${EXPLORER_ORIGIN}/;
        proxy_http_version          1.1;
        proxy_set_header Host       $host;
        proxy_set_header X-Real-IP  $remote_addr;
        proxy_hide_header Access-Control-Allow-Origin;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        add_header Access-Control-Allow-Origin  *;
        add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
        add_header Access-Control-Allow-Headers 'Content-Type, Authorization';
        if ($request_method = OPTIONS) {
            add_header Access-Control-Allow-Origin  *                                       always;
            add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'                   always;
            add_header Access-Control-Allow-Headers 'Content-Type, Authorization'          always;
            add_header Content-Length 0;
            add_header Content-Type text/plain;
            return 204;
        }
    }
}

# zk-kyc.${DOMAIN} :443
server {
    listen 443 ssl; listen [::]:443 ssl;
    server_name zk-kyc.${DOMAIN};

    ssl_certificate     /etc/nginx/ssl/live/zk-kyc.${DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/nginx/ssl/live/zk-kyc.${DOMAIN}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    location / {
        proxy_pass http://${ZKOS_KYC_HOST}/;  
        proxy_http_version          1.1;
        proxy_set_header Host       $host;
        proxy_set_header X-Real-IP  $remote_addr;
        proxy_hide_header Access-Control-Allow-Origin;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        add_header Access-Control-Allow-Origin  *;
        add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
        add_header Access-Control-Allow-Headers 'Content-Type, Authorization';
        if ($request_method = OPTIONS) {
            add_header Access-Control-Allow-Origin  *                                       always;
            add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'                   always;
            add_header Access-Control-Allow-Headers 'Content-Type, Authorization'          always;
            add_header Content-Length 0;
            add_header Content-Type text/plain;
            return 204;
        }
    }
}
