# (http context)
# load_module modules/ngx_http_js_module.so;
error_log /dev/stderr info;
map $http_upgrade $connection_upgrade {
  default upgrade;
  ''      close;
}
client_max_body_size 10m;
client_body_buffer_size 128k;
# ---- njs & resolver (for ngx.fetch and verify.js) ----
resolver 1.1.1.1 1.0.0.1 valid=300s ipv6=off;
js_path /etc/nginx/njs;
js_import verify from verify.js;
map "" $njs_debug { default "1"; }
# Vars used by verify.js
# - Set VERIFIER_URL in your env (e.g., http://verifier:8080)
# - RPC_UPSTREAM_URL will be derived from ${RPC_HOST}; NO trailing slash
map "" $verifier_url     { default "${VERIFIER_URL}"; }
map "" $rpc_upstream_url { default "http://${RPC_HOST}"; }

# ---- upstreams (parameterize if you like) ----
upstream relayer     { server ${RELAYER_BACKEND}; }
upstream orderapi    { server ${ORDERAPI_BACKEND};  }
upstream auth        { server ${AUTH_BACKEND};       }
upstream api         { server ${WEB_BACKEND};       }
upstream ws          { server ${WS_BACKEND};        }
upstream whitelist   { server ${WHITELIST_HOST};    }

# ---------- :80 redirectors ----------
# relayer.${DOMAIN}
server {
  listen 80; listen [::]:80;
  server_name relayer.${DOMAIN} www.relayer.${DOMAIN};
  server_tokens off;
  location /.well-known/acme-challenge/ { root /var/www/certbot; }
  location / { return 301 https://relayer.${DOMAIN}$request_uri; }
}

# frontend.${DOMAIN}
server {
  listen 80; listen [::]:80;
  server_name frontend.${DOMAIN} www.frontend.${DOMAIN};
  server_tokens off;
  location /.well-known/acme-challenge/ { root /var/www/certbot; }
  location / { return 301 https://frontend.${DOMAIN}$request_uri; }
}

# lcd.${DOMAIN}
server {
    listen 80; listen [::]:80;
    server_name lcd.${DOMAIN} www.lcd.${DOMAIN};
    server_tokens off;
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }
    location / {
        return 301 https://lcd.${DOMAIN}$request_uri;
    }
}

# rpc.${DOMAIN}
server {
    listen 80; listen [::]:80;
    server_name rpc.${DOMAIN} www.rpc.${DOMAIN};
    server_tokens off;
    location /.well-known/acme-challenge/ { root /var/www/certbot; }
    location / { return 301 https://rpc.${DOMAIN}$request_uri; }
}

# zkos.${DOMAIN}
server {
    listen 80; listen [::]:80;
    server_name zkos.${DOMAIN} www.zkos.${DOMAIN};
    server_tokens off;
    location /.well-known/acme-challenge/ { root /var/www/certbot; }
    location / { return 301 https://zkos.${DOMAIN}$request_uri; }
}

# faucet.${DOMAIN}
server {
    listen 80; listen [::]:80;
    server_name faucet.${DOMAIN} www.faucet.${DOMAIN};
    server_tokens off;
    location /.well-known/acme-challenge/ { root /var/www/certbot; }
    location / { return 301 https://faucet.${DOMAIN}$request_uri; }
}

# explorer.${DOMAIN}
server {
    listen 80; listen [::]:80;
    server_name explorer.${DOMAIN} www.explorer.${DOMAIN};
    server_tokens off;
    location /.well-known/acme-challenge/ { root /var/www/certbot; }
    location / { return 301 https://explorer.${DOMAIN}$request_uri; }
}

# zk-kyc.${DOMAIN}
server {
    listen 80; listen [::]:80;
    server_name zk-kyc.${DOMAIN} www.zk-kyc.${DOMAIN};
    server_tokens off;
    location /.well-known/acme-challenge/ { root /var/www/certbot; }
    location / { return 301 https://zk-kyc.${DOMAIN}$request_uri; }
}

# ---------- relayer.${DOMAIN} :443 ----------
server {
  listen 443 ssl; listen [::]:443 ssl;
  http2 on;
  server_name relayer.${DOMAIN};

  ssl_certificate     /etc/nginx/ssl/live/relayer.${DOMAIN}/fullchain.pem;
  ssl_certificate_key /etc/nginx/ssl/live/relayer.${DOMAIN}/privkey.pem;

  location /relayer   { proxy_pass http://relayer; }
  location /clientapi { proxy_pass http://orderapi; }
  location /whitelist { 
    proxy_pass http://whitelist;
    proxy_http_version 1.1;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    add_header Access-Control-Allow-Origin *;
    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
    add_header Access-Control-Allow-Headers 'Content-Type, Authorization';
  }

  location /ws {
    proxy_pass http://ws;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $connection_upgrade;
  }

  location = /check        { proxy_pass http://api; }
  location = /api/private  { proxy_pass http://api; }
  location /api            { proxy_pass http://api; }

  location = /register     { proxy_pass http://auth/register; }
  location = /regenerate   { proxy_pass http://api; }
}

# ---------- lcd.${DOMAIN} :443 (1317) ----------
server {
  listen 443 ssl; listen [::]:443 ssl;
  server_name lcd.${DOMAIN};
  ssl_certificate     /etc/nginx/ssl/live/lcd.${DOMAIN}/fullchain.pem;
  ssl_certificate_key /etc/nginx/ssl/live/lcd.${DOMAIN}/privkey.pem;

  location / {
    proxy_pass http://${LCD_HOST}/;
    proxy_http_version 1.1;
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
    add_header Access-Control-Allow-Headers 'Content-Type, Authorization';
    if ($request_method = OPTIONS) {
      add_header Content-Length 0;
      add_header Content-Type text/plain;
      return 204;
    }
  }
}

# ---------- rpc.${DOMAIN} :443 (26657 + WS) ----------
# server {
#   listen 443 ssl; listen [::]:443 ssl;
#   server_name rpc.${DOMAIN};
#   ssl_certificate     /etc/nginx/ssl/live/rpc.${DOMAIN}/fullchain.pem;
#   ssl_certificate_key /etc/nginx/ssl/live/rpc.${DOMAIN}/privkey.pem;

#   # SINGLE PUBLIC ROUTE: all traffic gated by verify.js on '/'
#   location / {
#     js_content verify.rpc;  # handles CORS, gating, and forwarding (preserves path+query)
#   }

#   # Internal-only WebSocket passthrough (verify.js redirects here on Upgrade)
#   location  /__ws_internal__  {
#     internal;
#     proxy_pass http://${RPC_HOST}/websocket;
#     proxy_http_version 1.1;

#     proxy_set_header Upgrade    $http_upgrade;
#     proxy_set_header Connection "upgrade";
#     proxy_read_timeout 60s;

#     # Optional CORS for WS responses
#     add_header Access-Control-Allow-Origin  *       always;
#     add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS' always;
#     add_header Access-Control-Allow-Headers 'Content-Type, Authorization' always;
#   }
# }

# # ---------- rpc.${DOMAIN} :443 (26657 + WS) ----------
# server {
#   listen 443 ssl; listen [::]:443 ssl;
#   server_name rpc.${DOMAIN};
#   ssl_certificate     /etc/nginx/ssl/live/rpc.${DOMAIN}/fullchain.pem;
#   ssl_certificate_key /etc/nginx/ssl/live/rpc.${DOMAIN}/privkey.pem;
#   # INTERNAL endpoint the njs script will subrequest to
#   # Proxies to your verifier (full URL provided via $verifier_url)
#   location = /__verifier {
#     internal;
#     proxy_pass $verifier_url;                    # e.g., http://verifier:8080
#     proxy_set_header Content-Type application/json;
#     proxy_pass_request_headers off;              # njs sets minimal headers
#   }

#   # SINGLE PUBLIC ROUTE (same as before), but now we gate in access phase
#   location / {
#     # njs gate (no fetch; only subrequest to /__verifier)
#     js_content verify.access;

#     proxy_pass http://${RPC_HOST};               # preserve path+query
#     proxy_http_version 1.1;

#     # WebSocket support
#     proxy_set_header Upgrade    $http_upgrade;
#     proxy_set_header Connection $connection_upgrade;
#     proxy_read_timeout 60s;

#     # CORS (keep your current behavior)
#     if ($request_method = OPTIONS) {
#       add_header Access-Control-Allow-Origin  * always;
#       add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS' always;
#       add_header Access-Control-Allow-Headers 'Content-Type, Authorization' always;
#       add_header Content-Length 0;
#       add_header Content-Type text/plain;
#       return 204;
#     }
#     # add_header Access-Control-Allow-Origin  * always;
#     add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS' always;
#     add_header Access-Control-Allow-Headers 'Content-Type, Authorization' always;
#   }
# }

server {
  listen 443 ssl; listen [::]:443 ssl;
  server_name rpc.${DOMAIN};
  ssl_certificate     /etc/nginx/ssl/live/rpc.${DOMAIN}/fullchain.pem;
  ssl_certificate_key /etc/nginx/ssl/live/rpc.${DOMAIN}/privkey.pem;

  # INTERNAL: njs subrequest target that calls your verifier service
  # IMPORTANT: set VERIFIER_URL env to FULL URL (e.g., http://verifier:8080/whitelist/status)
  location = /__verifier {
    internal;
    # proxy_pass $verifier_url;                    # e.g., http://verifier:8080/whitelist/status
    # proxy_set_header Content-Type application/json;
    # proxy_pass_request_headers off;

    proxy_pass $verifier_url;

    proxy_http_version 1.1;
    proxy_set_header Host $proxy_host;
    proxy_set_header Content-Type application/json;
    proxy_set_header Connection "";            # avoid "Connection: keep-alive" quirks
    proxy_connect_timeout 2s;
    proxy_read_timeout 5s;

    # Ensure dynamic DNS works for proxy_pass variable (can also be at http{} – you already have it there)
    resolver 1.1.1.1 1.0.0.1 valid=300s ipv6=off;

    # If $verifier_url is HTTPS with a hostname, turn on SNI:
    proxy_ssl_server_name on;

  }

  # INTERNAL: actual upstream pass-through. Named location keeps original URI.
  location @up {
    proxy_pass http://${RPC_HOST};               # no URI part → preserves original path+query
    proxy_http_version 1.1;

    # WS support
    proxy_set_header Upgrade    $http_upgrade;
    proxy_set_header Connection $connection_upgrade;
    proxy_read_timeout 60s;

    # Avoid duplicate CORS from upstream
    proxy_hide_header Access-Control-Allow-Origin;
    proxy_hide_header Access-Control-Allow-Methods;
    proxy_hide_header Access-Control-Allow-Headers;

    # Our single CORS set on ALL responses (incl. 4xx/5xx/101)
    add_header Access-Control-Allow-Origin  *                                  always;
    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'               always;
    add_header Access-Control-Allow-Headers 'Content-Type, Authorization'      always;
  }

  # PUBLIC: single route. njs does gating, then jumps to @up if allowed.
  location / {
    js_content verify.access;   # <— use js_content, not js_access
  }
}

# ---------- frontend.${DOMAIN} -> frontend ----------
server {
  listen 443 ssl; listen [::]:443 ssl;
  server_name frontend.${DOMAIN};
  ssl_certificate     /etc/nginx/ssl/live/frontend.${DOMAIN}/fullchain.pem;
  ssl_certificate_key /etc/nginx/ssl/live/frontend.${DOMAIN}/privkey.pem;

  location / {
    proxy_pass http://${FRONTEND};
    proxy_http_version 1.1;
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    add_header Access-Control-Allow-Origin  *;
    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
    add_header Access-Control-Allow-Headers 'Content-Type, Authorization';
    if ($request_method = OPTIONS) {
      add_header Content-Length 0;
      add_header Content-Type text/plain;
      return 204;
    }
  }
}

# zkos.${DOMAIN} :443
server {
    listen 443 ssl; listen [::]:443 ssl;
    server_name zkos.${DOMAIN};

    ssl_certificate     /etc/nginx/ssl/live/zkos.${DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/nginx/ssl/live/zkos.${DOMAIN}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    location / {
      proxy_pass http://${ZKOS_HOST};
    }
}

# faucet.${DOMAIN} :443 (6969)
server {
    listen 443 ssl; listen [::]:443 ssl;
    server_name faucet.${DOMAIN};

    ssl_certificate     /etc/nginx/ssl/live/faucet.${DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/nginx/ssl/live/faucet.${DOMAIN}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    location / {
        proxy_pass http://${FAUCET_HOST}/;
        proxy_http_version          1.1;
        proxy_set_header Host       $host;
        proxy_set_header X-Real-IP  $remote_addr;
        proxy_hide_header Access-Control-Allow-Origin;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        add_header Access-Control-Allow-Origin  *;
        add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
        add_header Access-Control-Allow-Headers 'Content-Type, Authorization';
        if ($request_method = OPTIONS) {
            add_header Access-Control-Allow-Origin  *                                      always;
            add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'                   always;
            add_header Access-Control-Allow-Headers 'Content-Type, Authorization'          always;
            add_header Content-Length 0;
            add_header Content-Type text/plain;
            return 204;
        }
    }
}

# explorer.${DOMAIN} :443
server {
    listen 443 ssl; listen [::]:443 ssl;
    server_name explorer.${DOMAIN};

    ssl_certificate     /etc/nginx/ssl/live/explorer.${DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/nginx/ssl/live/explorer.${DOMAIN}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    location / {
        proxy_pass http://${EXPLORER_ORIGIN}/;
        proxy_http_version          1.1;
        proxy_set_header Host       $host;
        proxy_set_header X-Real-IP  $remote_addr;
        proxy_hide_header Access-Control-Allow-Origin;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        add_header Access-Control-Allow-Origin  *;
        add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
        add_header Access-Control-Allow-Headers 'Content-Type, Authorization';
        if ($request_method = OPTIONS) {
            add_header Access-Control-Allow-Origin  *                                       always;
            add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'                   always;
            add_header Access-Control-Allow-Headers 'Content-Type, Authorization'          always;
            add_header Content-Length 0;
            add_header Content-Type text/plain;
            return 204;
        }
    }
}

# zk-kyc.${DOMAIN} :443
server {
    listen 443 ssl; listen [::]:443 ssl;
    server_name zk-kyc.${DOMAIN};

    ssl_certificate     /etc/nginx/ssl/live/zk-kyc.${DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/nginx/ssl/live/zk-kyc.${DOMAIN}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    location / {
        proxy_pass http://${ZKOS_KYC_HOST}/;  
        proxy_http_version          1.1;
        proxy_set_header Host       $host;
        proxy_set_header X-Real-IP  $remote_addr;
        proxy_hide_header Access-Control-Allow-Origin;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        add_header Access-Control-Allow-Origin  *;
        add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
        add_header Access-Control-Allow-Headers 'Content-Type, Authorization';
        if ($request_method = OPTIONS) {
            add_header Access-Control-Allow-Origin  *                                       always;
            add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'                   always;
            add_header Access-Control-Allow-Headers 'Content-Type, Authorization'          always;
            add_header Content-Length 0;
            add_header Content-Type text/plain;
            return 204;
        }
    }
}
